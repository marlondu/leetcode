package problem1_100

import (
	"fmt"
	"math"
)

//给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
//
//请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
//
//你可以假设 nums1 和 nums2 不会同时为空。
//
//示例 1:
//
//nums1 = [1, 3]
//nums2 = [2]
//
//则中位数是 2.0
//示例 2:
//
//nums1 = [1, 2]
//nums2 = [3, 4]
//
//则中位数是 (2 + 3)/2 = 2.5
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 题解 关键字 减半删除
// 所谓中位数，就是一组数字按顺序排好后，取中间一个数，这个数之前的数字都比他小，之后的数字都比他大
// 如果数字个数N是奇数,则正好索引(N - 1)/2 的数是中位数，如果数字个数N是偶数个，则中位数是n[(N-1) - 1]/2 + n[N/2]) / 2
// 例如数组[1, 2, 3] 则中位数是2, 数组[1,2,3,4],则中位数(2+3)/2 == 2.5
// 在这道题中分为了两个有序数组，如果是先将两个数组合并成一个有序数组的话，也就是归并排序的最后一步，时间复杂度是O(m+n)显然不符合要求
// 我们只是要找到中位数，两边的数我们是不需要关心的。
// 所以我们只需要两个指针，开始指向开头，然后比较，哪个数小，哪个指针向右移动一位。移动到指定位置求出中位数。此时时间O((m+n)/2)
// 时间复杂度都不符合要求
//  所以在两个指针的基础上，我们一已经知道移动要移动多少位，我是不是没必要一位一位的移动了。
// 其实题目要求时间复杂度为log(m+n) 我们可能就想到是使用二分法。
// 分两种情况，看数字一共有多少个，这样可以确定我们要找一个数还是两个数
// 情况一，假如数字一共13个，则中位数是第7( (13 + 1) / 2)个数。
// i
// v
// 1 2 5 7  8 11 13 (A
// 3 4 6 9 10 12    (B
// ^
// j
// 第一次我们删掉k/2个数，也就是3个数，此时我们判断A[i+2] 和B[j+2]两个数哪个大，如果A[i+2] < B[j+2],则我们删除A[i+2]，也即是将指针i右移3
// 因为A[i+2]一定不是第7个数.利用反证法，假如A[i+2]是7大的数，因为B[j+2]>A[i+2],那么前面最多有5个数，不是7个。
//       i
//       v
// 1 2 5 7  8 11 13 (A
// 3 4 6 9 10 12    (B
// ^
// j
// 删掉3个后，k = (7 - 3) = 4, 接下来我们要删掉2个。同样的道理，此时还是比较A[i+1]和B[j+1]哪个大，显然B[j+1]=4 < A[i+1]=8
// 此时j指针向右移动2位
//       i
//       v
// 1 2 5 7  8 11 13 (A
// 3 4 6 9 10 12    (B
//     ^
//     j
// 第一次删除了3个，第二次删除了2个，接下来再删除1个即可。找到第7个数
// 此时比较A[i]和B[j]哪个大。B[j] < A[i], 删除B[j],得到中位数A[i] = 7
//
// 如果数组A,B一个数字很多，一个数字很少。少的数字都 不够k/2个数。
//       i
//       v
// 1 2 5 6 7 8 9 11 12 13 (A
// 3 4                    (B
// ^
// j
// 则直接删除多的数组即可。因为删掉的k/2个加上稍等不足k/2个都不够k个。删掉的一定不是第k大的数
// ---------------------------------------------------------------------
// 下面我们来看偶数个的情况
// i
// v
// 1 2 5 7  8 11 13 (A
// 3 4 6 9 10 12 14 (B
// ^
// j
// 假设A,B数组共有数14个数，则我们要找到第7个数和第8个数，同理要删除前7个。
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	// 看下总数是奇数还是偶数
	var count = len(nums1) + len(nums2)
	if count%2 == 0 {
		return float64(findKth(nums1, 0, nums2, 0, count/2)+findKth(nums1, 0, nums2, 0, count/2+1)) / 2.0
	} else {
		return float64(findKth(nums1, 0, nums2, 0, (count+1)/2))
	}
}

// 查找第K个值
func findKth(nums1 []int, i int, nums2 []int, j int, k int) int {
	for {
		if i >= len(nums1) { //  如果第一个数组已经都删完了
			return nums2[j+k-1] // 直接返回第k个数
		}
		if j >= len(nums2) {
			return nums1[i+k-1]
		}
		fmt.Printf("i: %d, j: %d, k: %d\n", i, j, k)
		if k == 1 {
			return int(math.Min(float64(nums1[i]), float64(nums2[j])))
		}
		//       i
		//       v
		// 1 2 5 7  8 11 13 (A
		// 3 4 6 9 10 12    (B
		//     ^
		//     j
		// 检查nums1[k/2]和nums[k/2]谁小
		//if nums1[k/2+i-1] < nums2[k/2+j-1] {
		//	i += k / 2
		//} else if nums1[k/2+i-1] > nums2[k/2+j-1] {
		//	j += k / 2
		//}
		var mid1 int
		if k/2+i-1 >= len(nums1) { // 越界，则删除另一个
			mid1 = math.MaxInt32
		} else {
			mid1 = nums1[k/2+i-1]
		}

		var mid2 int
		if k/2+j-1 >= len(nums2){ // 越界，则删除另一个
			mid2 = math.MaxInt32
		} else {
			mid2 = nums2[k/2+j-1]
		}
		if mid1 <= mid2 {
			i += k/2
		} else if mid2 < mid1 {
			j += k/2
		}
		k -= k/2
	}
	//return findKth(nums1, i, nums2, j, k-k/2)
}
